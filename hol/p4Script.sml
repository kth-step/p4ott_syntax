(* generated by Ott 0.31 from: ../ott/p4.ott *)
(* to compile: Holmake p4Theory.uo   *)
(* for interactive use:
  app load ["pred_setTheory","finite_mapTheory","stringTheory","containerTheory","ottLib"];
*)

open HolKernel boolLib Parse bossLib ottLib;
infix THEN THENC |-> ## ;
local open arithmeticTheory stringTheory containerTheory pred_setTheory listTheory 
  finite_mapTheory in end;

val _ = new_theory "p4";


open bitstringTheory;
open wordsTheory;
open alistTheory;

val _ = type_abbrev("x", ``:string``); (* string *)
val _ = type_abbrev("b", ``:bool``); (* boolean *)
val _ = type_abbrev("bl", ``:bool list``); (* bit-string *)
val _ = type_abbrev("i", ``:num``); (* natural number *)
val _ = type_abbrev("m", ``:num``); (* indices *)
val _ = type_abbrev("bitv", ``:(bl # num)``);
val _ = type_abbrev("boolv", ``:bool``);
val _ = type_abbrev("num_exp", ``:num``);


val _ = Hol_datatype ` 
funn = 
   funn_name of x (* function name *)
 | funn_inst of x (* extern object instantiation *)
 | funn_ext of x => x (* extern method call *)
`;
val _ = Hol_datatype ` 
varn = 
   varn_name of x (* variable name *)
 | varn_star of funn (* function return placeholder *)
 | varn_ext_ret (* extern return variable *)
`;
val _ = Hol_datatype ` 
v =  (* value *)
   v_bool of boolv (* boolean value *)
 | v_bit of bitv (* bit-string *)
 | v_str of x (* string literal *)
 | v_struct of (x#v) list (* struct *)
 | v_header of boolv => (x#v) list (* header *)
 | v_err of x (* error message *)
 | v_ext_ref of i (* extern object reference *)
 | v_bot (* no value *)
`;
val _ = Hol_datatype ` 
lval = 
   lval_varname of varn (* variable name *)
 | lval_null (* null variable *)
 | lval_field of lval => x (* field access *)
 | lval_slice of lval => i => i (* bit-slice *)
 | lval_paren of lval
`;
val _ = type_abbrev("scope", ``:((varn, (v # lval option)) alist)``);
val _ = Hol_datatype ` 
mk =  (* matching kinds *)
   mk_exact
 | mk_ternary
 | mk_lpm
`;
val _ = type_abbrev("v_list", ``:(v list)``);
val _ = type_abbrev("g_scope", ``:scope``);
val _ = Hol_datatype ` 
status =  (* execution status *)
   status_running
 | status_returnv of v
 | status_trans of x (* transition to parser state *)
`;


val _ = Hol_datatype ` 
unop = 
   unop_neg (* negation *)
 | unop_compl (* bitwise complement *)
 | unop_neg_signed (* signed negation *)
 | unop_un_plus (* unary plus *)
`;
val _ = Hol_datatype ` 
binop = 
   binop_mul (* multiplication *)
 | binop_div (* division *)
 | binop_mod (* modulo *)
 | binop_add (* addition *)
 | binop_sub (* subtraction *)
 | binop_shl (* logical left-shift *)
 | binop_shr (* logical right-shift *)
 | binop_le (* less or equal *)
 | binop_ge (* greater or equal *)
 | binop_lt (* less *)
 | binop_gt (* greater *)
 | binop_neq (* not equal *)
 | binop_eq (* equal *)
 | binop_and (* bitwise and *)
 | binop_xor (* bitwise xor *)
 | binop_or (* bitwise or *)
 | binop_bin_and (* binary and *)
 | binop_bin_or (* binary or *)
`;
val _ = Hol_datatype ` 
e =  (* expression *)
   e_v of v (* value *)
 | e_var of varn (* variable *)
 | e_list of e list (* expression list *)
 | e_acc of e => x (* field access *)
 | e_unop of unop => e (* unary operation *)
 | e_binop of e => binop => e (* binary operation *)
 | e_cond of e => e => e (* conditional *)
 | e_concat of e => e (* concatenation of bit-strings *)
 | e_slice of e => e => e (* bit-slice *)
 | e_call of funn => e list (* function or extern call *)
 | e_select of e => (v#x) list => x (* select *)
 | e_struct of (x#e) list (* struct *)
 | e_header of boolv => (x#e) list (* header *)
`;
val _ = type_abbrev("mk_list", ``:(mk list)``);


val _ = type_abbrev("e_list", ``:(e list)``);


val _ = type_abbrev("g_scope_list", ``:(scope list)``);
val _ = type_abbrev("scope_list", ``:(scope list)``);



val _ = Hol_datatype ` 
d =  (* parameter direction *)
   d_in
 | d_out
 | d_inout
 | d_none
`;
val _ = type_abbrev("x_list", ``:(x list)``);
val _ = Hol_datatype ` 
struct_ty = 
   struct_ty_struct
 | struct_ty_header
`;
val _ = type_abbrev("ff", ``:('a -> 'a option)``);
val _ = Hol_datatype ` 
tau =  (* type *)
   tau_bool (* boolean *)
 | tau_bit of num_exp (* bit-string *)
 | tau_bot (* no value *)
 | tau_xtl of struct_ty => (x#tau) list (* struct *)
 | tau_xl of x_list (* string literal *)
 | tau_err
 | tau_ext
`;
val _ = type_abbrev("d_list", ``:(d list)``);
val _ = type_abbrev("taul", ``:(tau list)``);
val _ = type_abbrev("ext_fun", ``:(('a # g_scope_list # scope_list) -> (('a # g_scope_list # scope_list) option))``);
val _ = type_abbrev("Ftau", ``:( ( tau # d ) list # tau)``);


val _ = type_abbrev("decl_list", ``:((varn # tau) list)``);
val _ = Hol_datatype ` 
stmt =  (* statement *)
   stmt_empty (* empty statement *)
 | stmt_ass of lval => e (* assignment *)
 | stmt_cond of e => stmt => stmt (* conditional *)
 | stmt_switch of e => (v#stmt) list (* switch *)
 | stmt_exit (* exit *)
 | stmt_block of decl_list => stmt (* block *)
 | stmt_ret of e (* return *)
 | stmt_seq of stmt => stmt (* sequence *)
 | stmt_verify of e => e (* verify *)
 | stmt_trans of e (* transition *)
 | stmt_app of x => e list (* apply *)
 | stmt_ext (* extern function *)
`;


val _ = type_abbrev("b_func_map", ``:((string, (stmt # (string # d) list)) alist)``);
val _ = type_abbrev("func_map", ``:((string, (stmt # (string # d) list)) alist)``);
val _ = type_abbrev("ext_fun_map", ``:((string, (stmt # (string # d) list # 'a ext_fun)) alist)``);


val _ = Hol_datatype ` 
pbl_type =  (* programmable block type *)
   pbl_type_parser
 | pbl_type_control
`;
val _ = type_abbrev("tbl_map", ``:((string, (mk list)) alist)``);
val _ = type_abbrev("pars_map", ``:((string, stmt) alist)``);
val _ = type_abbrev("ext_map", ``:((string, (((stmt # (string # d) list # 'a ext_fun) option) # 'a ext_fun_map)) alist)``);
val _ = type_abbrev("in_out", ``:(bl # num)``);
val _ = Hol_datatype ` 
pblock =  (* programmable block *)
   pblock_regular of pbl_type => (x#d) list => b_func_map => decl_list => stmt => pars_map => tbl_map
`;
val _ = Hol_datatype ` 
ffblock =  (* fixed-function block *)
   ffblock_ff of 'a ff
`;


val _ = type_abbrev("ffblock_map", ``:((string, 'a ffblock) alist)``);
val _ = type_abbrev("pblock_map", ``:((string, pblock) alist)``);
val _ = type_abbrev("in_out_list", ``:(in_out list)``);
val _ = Hol_datatype ` 
arch_block =  (* architectural block *)
   arch_block_inp
 | arch_block_pbl of x => e list
 | arch_block_ffbl of x
 | arch_block_out
`;
val _ = type_abbrev("pblock_list", ``:(pblock list)``);


val _ = type_abbrev("output_f", ``:((in_out_list # 'a) -> (in_out_list # 'a) option)``);
val _ = type_abbrev("copyin_pbl", ``:((x list # d list # e list # 'a # pbl_type) -> scope option)``);
val _ = type_abbrev("input_f", ``:((in_out_list # 'a) -> (in_out_list # 'a) option)``);
val _ = type_abbrev("copyout_pbl", ``:((g_scope list # 'a # d list # x list # pbl_type # status) -> 'a option)``);
val _ = type_abbrev("apply_table_f", ``:((x # e_list # mk_list # 'a) -> (x # e_list) option)``);
val _ = type_abbrev("ab_list", ``:(arch_block list)``);


val _ = type_abbrev("actx", ``:(ab_list # pblock_map # 'a ffblock_map # 'a input_f # 'a output_f # 'a copyin_pbl # 'a copyout_pbl # 'a apply_table_f # 'a ext_map # func_map)``);
val _ = type_abbrev("ctx", ``:('a apply_table_f # 'a ext_map # func_map # b_func_map # pars_map # tbl_map)``);

val _ = export_theory ();



